# Step.1 웹사이트 분석 미션

- **네이버 웹사이트 분석 (www.navre.com)**

- **네이버의 HTML 속  js, css 위치** 

  > ■ HTML 문서 속 JS와 CSS 위치 
  >
  > - **CSS**
  >
  >   : 문서를 파싱해서 DOM Tree를 만들어도 **스타일 규칙이 없으면 렌더링 할 수가 없다**. 최대한 빨리 스타일 규칙을 알아야 렌더링트리가 완전히 만들어지므로 스타일시트를 모두 다운로드 시키기 위해 <head></head> 태그 사이에 CSS를 위치시킨다. 
  >
  >   CSS를 하단에 위치시키면 HTML 파일을 한번 읽은 뒤 다시 읽어 적용시키게 되므로 느려진다.
  >
  > - **JS**
  >
  >   : 자바스크립트는 DOM 객체를 이용해서 컴포넌트들을 조작하는데 <head></head> 태그 사이처럼 상단에 놓게 되면 HTML 파서가 파싱을 멈추고 스크립트파일을 읽는다. 위에서 스크립트 파일이 많거나 파일이 크면 파싱을 멈추고 스크립트 파일을 읽는 시간이 오래 걸려 사용자 입장에서 웹페이지가 느리게 보이게 된다. 
  >
  >   심지어, 잘못 코딩했을 경우 HTMl 파싱보다 자바스크립트 파일이 먼저 실행되어서 적용이 안 되는 경우도 생길 수 있다. 
  >
  >   하지만 html태그가 읽히기전에 수행되어야하는 <script>태그들은 윗부분에 위치시켜야 한다.
  >
  >   
  >
  >   *ex1) 자바스크립트 애니메이션의 경우 화면상에서 바로 적용시켜줘야 하므로 애니메이션 관련 부분만 <head></head> 태그 사이로 올려서 적용하기도 한다.*
  >
  >   *ex2) 자바스크립트로 사용자 화면의 일부 콘텐츠를 보여주거나 감추는 동작을 실행할 경우도 <head></head> 사이에 자바스크립트 코드를 넣는 것이 좋다. 이 경우에 자바스크립트 코드를 <body></body> 사이에 포함할 경우 자바스크립트가 HTML보다 늦게 해석이 되면서 일시적으로 깨진 화면이 보일 수 있다. -> <head></head>에 포함된 자바스크립트 코드는 HTML 문서보다 먼저 해석이 되지만, HTMl 문서의 로딩이 완료된 이후에 실행하도록 코드를 작성해야한다.*
  >
  >   
  >
  >   ※ 브라우저가 스크립트의 비동기 및 지연 특성을 지원하는 것을 이용해, 스크립트가 다운로드 되는 동안 계속 구문 분석을 하는 것이 안전하다는 것을 브라우저에게 알려줄 수 있다. (async/defer) 

  

  - 네이버의 css 위치는 <head></head>  사이에 위치

  - js의 위치는 <head></head> 사이와 </body> 바로 위쪽에 위치해 있다.

    - <head></head> 사이에 위치한 자바스크립트 코드

```html
      <script type="text/javascript">
      var nsc = "navertop.v3";
      document.domain = "naver.com";
      var jindoAll = "";
      var iframeLazyLoad = false;
      if (!!!window.console) {window.console={};window.console["log"]=function(){}}
      var isLogin = false; 
      function refreshLcs(etc) {etc = etc ? etc : {};if(document.cookie.indexOf("nrefreshx=1") != -1) {etc["mrf"]="1";} else {etc["pan"]="gam";}return etc;}
      </script>
```

※ 더미 console 객체 (참고)
      
실제로 console 객체를 사용하는 경우에는 console의 코드를 제거해야 하지만 개발 중에 약간 테스트하고 싶을 경우에 일부로 console 코드를 제거하는 것도 번거로운 일이 될 것입니다.
      
그래서 인터넷 익스플로러 등의 console 객체가 존재하지 않는 브라우저에서도 에러가 발생하지 않도록 더미 console 객체를 넣는 방법을 이용하기도 합니다.
      
파이어버그의 console 객체에 포함된 모든 메서드를 제공하는 더미 console 객체는 다음의 아래처럼 작성할 수 있습니다.
      
이를 최초로 읽는 자바스크립트 코드의 맨 위에 작성해 두면 console 호출로 에러가 생기는 일은 없어질 것입니다.
      
실제로 릴리지할 때는 console.log 등의 코드와 함께 이 코드도 제거할 수 있도록 해야 합니다.
      


출처: https://webclub.tistory.com/464 [Web Club]
      

- **화면을 표시하기 위해 다운로드 되는 파일들**

  - CSS 파일, JS 파일, png, jpeg 등 화면을 표현하기 위해 필요한 파일들이 다운로드 된다.

- **특정 자원의 Request Headers와 Response Headers의 내용을 분석**

  - **Request Header**

    ```
    :authority: www.naver.com
    :method: GET
    :path: /
    :scheme: https
    accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
    accept-encoding: gzip, deflate, br
    accept-language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
    cache-control: max-age=0
    cookie: NNB=C4SEYFSS6LFFY; ASID=277362600000016a9353764900000059; NaverSuggestUse=use%26unuse; MM_NEW=1; NFS=2; _ga_4BKHBFKFK0=GS1.1.1577249228.2.0.1577249228.60; _ga=GA1.2.724527621.1577198972; NRTK=ag#all_gr#1_ma#-2_si#0_en#0_sp#0; nid_inf=1141730655; NID_JKL=X0UmkwodasIVWjcJMd2b+PRIst5okzo6NeuTGGHxKw0=; _gid=GA1.2.2072550961.1580711847; PM_CK_sclFixed=1; BMR=s=1580714443243&r=https%3A%2F%2Fm.blog.naver.com%2FPostView.nhn%3FblogId%3Dwebwizard83%26logNo%3D220589390813%26proxyReferer%3Dhttps%253A%252F%252Fwww.google.com%252F&r2=https%3A%2F%2Fwww.google.com%2F; nx_ssl=2; PM_CK_loc=95ffe18676d1022a0207a0d47c3c90b165d0568edbaa5ec42c6be4e35784e090; page_uid=UBlgElp0J1ssscxglDdssssstcG-296997
    referer: https://www.naver.com/
    sec-fetch-mode: navigate
    sec-fetch-site: same-origin
    sec-fetch-user: ?1
    upgrade-insecure-requests: 1
    user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36
    ```

    - GET 방식의 method 사용

    - uri scheme은 https

    - accept : 요청을 보낼 때 서버에 어떤 타입의 데이터를 보내줬으면 좋겠다고 명시할 때 사용 (클라이언트가 허용할 수 있는 파일의 형식 MIME TYPE)

      (;q =0.9 -> 이런 건 weight 나타낼 때 사용하는 것)

      - accept-encoding : 인코딩 알고리즘은 gzip, deflate, br (압축 알고리즘들)이다

        : 응답컨텐츠를 저 압축 알고리즘으로 보내면 브라우저가 알아서 해체해서 사용

        *※ 모든 모던 브라우저와 서버들은 종단간 압축을 지원하며 협상하는 유일한 것은 사용할 압축 알고리즘입니다. 이런 압축 알고리즘들은 텍스트에 최적화되어 있습니다. 1990년대에, 압축 기술은 급격한 속도로 진보되고 있었으며 많은 수의 성공적인 알고리즘들이 선택 가능한 후보군에 추가되었습니다. 오늘날에는, 오직 두 개의 알고리즘만이 적절한 후보군입니다: 가장 일반적인 `gzip`, 그리고 새로운 도전자인 `br`이 그것이죠.*

      - accept-language : 서버가 보내 줄 예상 언어

      - cache-control: max-age=0 

        : 네트워크를 통해 무언가를 가져오는 작업은 느린 동시에 비용도 많이 들기 때문에, 이전에 가져온 리소스를 캐시했다가 재활용할 수 있는 기능이 브라우저의 HTTP 캐시

        : Cache-Control 지시문은 응답을 캐시할 수 있는 사용자, 해당 조건 및 기간을 제어한다.

        - no-cache : 반환된 응답이 변경된 경우 서버와 먼저 확인하지 않고는 동일한 URL에 대한 후속 요청을 충족하는 데 사용할 수 없다. 적절한 유효성 검사 토큰이 있을 경우 no-cache는 캐시된 응답의 유효성을 검사하는 데 한 번의 왕복을 발생시키지만, 리소스가 변경되지 않은 경우 다운로드를 제거할 수 있다.

        - no-store : 브라우저와 모든 중간 캐시는 반환된 응답의 모든 버전을 저장할 수 없다. 사용자가 요청할 때마다 요청이 서버에 전송되고 전체 응답이 다운로드 된다.

        - 'public' vs. 'private'

          응답이 'public'으로 표시되면 이와 관련된 HTTP 인증이 구성되어 있고 응답 상태 코드가 정상적으로 캐시할 수 없는 경우에도 캐시가 가능하다. 대부분의 경우, 명시적 캐싱 정보(예: 'max-age')가 응답이 어떠한 경우든지 캐시가 가능하다고 나타내므로 'public' 생략 가능하다.

          반대로, 'private' 응답은 브라우저가 캐시할 수 있다. 그러나 일반적으로 이 응답은 단일 사용자를 대상으로 하므로 중간 캐시가 이 응답을 캐시하는 것은 허용되지 않습니다. 예를 들어, 비공개 사용자 정보가 포함된 HTML 페이지는 사용자의 브라우저가 캐시할 수 있지만, CDN은 이 페이지를 캐시할 수 없습니다.

        - max-age :  요청 시간부터 가져온 응답을 재활용할 수 있는 최대 시간(초)을 지정한다. 예를 들어, 'max-age=60'은 응답이 다음 60초 동안 캐시되어 재활용될 수 있음을 나타냅니다.

        - https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=ko

        - max-age=0 과 no-cashe 의 차이? https://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache

        - cache-control 설명 [https://www.letmecompile.com/http-cache-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/](https://www.letmecompile.com/http-cache-튜토리얼/)

  - **Response Header**

    ```
    cache-control: no-cache, no-store, must-revalidate
    content-encoding: gzip
    content-type: text/html; charset=UTF-8
    date: Mon, 03 Feb 2020 14:46:21 GMT
    p3p: CP="CAO DSP CURa ADMa TAIa PSAa OUR LAW STP PHY ONL UNI PUR FIN COM NAV INT DEM STA PRE"
    pragma: no-cache
    referrer-policy: unsafe-url
    server: NWS
    status: 200
    strict-transport-security: max-age=63072000; includeSubdomains
    x-frame-options: DENY
    x-xss-protection: 1; mode=block
    ```

    - cache-control 

      - no-cache, no-store, must-revalidate(서버에 꼭 유효성 검사를 해야함)

    - content-encoding 은 gzip 알고리즘 사용

    - content type은 텍스트, 문자는 utf-8사용

    - pragma:no-cashe

      : HTTP/1.0 버전에서 사용하던 HTTP/1.1 버전의 Cashe-Control 역할을 하던 것

    - referrer-policy : unsfae-url

      : referrer은 웹에서 돌아다닐 때, 이전 방문 페이지

      : 이를 통해 어디 페이지에서 접속하는지 추적이 가능하다

      - unsafe-url이 기본값이라고 한다...

    - status : 응답 상태를 나타내는 코드 (ex.200 요청 정상 처리)

      - 1xx : 정보성
      - 2xx : 성공
      - 3xx : 리다이렉트
      - 4xx : 클라이언트 오류
      - 5xx : 서버 오류

    - strict-transport-security 

      : 웹사이트에 접속할 때 강제적으로, HTTPS protocol로만 접속하게 하는 기능

      ※ **HSTS 기능을 사용하는 목적**

      사용자가 특정 Web Site에 접속할 때, 해당 Web Site가 HTTPS Protocol을 지원하는 지, 하지 않는 지 알지 못하는 경우가 대부분입니다. 따라서 Web Browser로 접속 시, 주소창에 “https://” 또는 “http://” 와 같은 Protocol 이름을 입력하지 않고, 단지 도메인 이름(예를 들면, www.naver.com)만 입력합니다.

       

      그러면, Web Browser는 먼저 HTTP Protocol(“http://” 사용)로 해당 도메인에 접속을 시도합니다. 해당 도메인이 HTTPS Protocol만을 지원하는 Web Site라면, ”301 Redirect” 또는 ”302 Redirect”   response를 보내어, Web Browser로 하여금 HTTPS Protocol로 다시 접속하라고 지시합니다.

       

      사용자는 접속한 후에, 주소창 옆에 있는 자물쇠 아이콘 또는 접속된 URL주소 앞에 있는 “https://”를 보고, 해당 Web Site가 지원하는 Protocol이 HTTPS Protocol 인지 인식하게 됩니다.

      :  Max Age 값은 HSTS List 에 존속하는 시간을 나타내며, Subdomain 에도 HSTS를 적용할 지 여부를 알려준다. Age 값이 0(zero)인 경우는 HSTS Policy를 삭제하라는 명령이다.

      https://m.blog.naver.com/PostView.nhn?blogId=aepkoreanet&logNo=221575708943&proxyReferer=https%3A%2F%2Fwww.google.com%2F

    - x-frame-options : clickjacking 공격을 방어하기 위해 사용한다고 함.

      ※ clickjacking : 웹 사용자가 자신이 클릭하고 있다고 인지하는 것과 다른 어떤 것을 클릭하게 속이는 악의적인 기법으로써 잠재적으로 공격자는 비밀 정보를 유출시키거나 그들의 컴퓨터에 대한 제어를 획득하게 될 수 있다. 

      위키피디아 '클릭재킹'

      [https://ko.wikipedia.org/wiki/%ED%81%B4%EB%A6%AD%EC%9E%AC%ED%82%B9](https://ko.wikipedia.org/wiki/클릭재킹)

      에서도 서버측에서 x-프레임 옵션을 조절해주는 것으로 클릭재킹을 예방할 수 있다고 나와있음

      : 옵션은 총 3가지

      ```
      1. DENY : 페이지를 frame 내에서 표시할 수 없다.
      
      2. SAMEORIGIN : 동일한 origin인 경우 페이지를 frame 내에서 표시할 수 있다.
      
      3. ALLOW-FROM uri : 지정된 origin의 페이지를 frame 내에서 표시할 수 있다.
      ```

      https://slobell.com/blogs/29

    - x-xss-protection: 1; mode=block

      : 크로스사이트스크립트를 탐지하면 웹 페이지를 사용자에게 아예 보여주지 말라는 의미

      ※ 크로스사이트스크립트 : 사이트 간 스크립팅, 웹사이트 관리자가 아닌 이가 웹 페이지에 악성 스크립트를 삽입할 수 있는 취약점.

      https://webhack.dynu.net/?idx=20161119.001

      

- **화면에 보여지기 시작하는 시간은 언제인가?**

  - DOMContentLoaded : 328 ms
  - load(on load) : 661ms

- **DOMContentLoaded 라는 이벤트는 언제 발생하는가?**

  - Dom Tree 분석이 끝나면 DOMContentLoaded 이벤트 발생

- **load와 DOMContentLoaded의 차이점**

  - load는 DOMContentLoaded 이벤트가 발생하고, 그 외 모든 자원을 다 받고 브라우저에 렌더링까지 다 끝난 시점에 발생 

  - 빠른 로딩속도를 위해 자바스크립트를 나중에 따로 로드할 수 있도록 하는 게 DOMContentLoaded와 load

  - DOMContentLoaded 이벤트는 최초 HTML 문서가 완전히 로드 및 파싱되었을 때 발생되고, 스타일시트나 이미지 및 서브프레임 로드가 끝나기를 기다리지 않음

  - load 이벤트는 문서의 모든 콘텐츠(images, script, css, etc)가 로드된 후 발생하는 이벤트 (모든 페이지가 완전히 로드되었을 때 사용해야 함)

  - Dom Tree가 다 만들어지면 DOM APIs를 통해서 DOM에 접근할 수 있기 때문에 실무에서 대부분의 자바스크립트 코드는 DOMContentLoaded 이후에 동작하도록 구현 -> 로딩 속도 성능에 유리하기 때문

    

- **웹 브라우저의 HTML 문서 렌더링 과정**

  1. **불러오기**

     : 로더(Loader)가 서버로부터 전달 받는 리소스 스트림을 읽는 과정, 읽으면서 어떤 파일이나 데이터인지, 파일을 다운로드 할 것인지 등을 결정한다. 

  2. **파싱(parsing)**

     : 웹 엔진이 가지고 있는 HTMl/XML 파서가 문서를 파싱해서 DOM Tree를 만든다.

     > **※ DOM tree** 
     >
     > : XML 및 HTML 문서를 응용프로그램에서 사용하기 위한 API 규격
     >
     > : DOM이란 문서의 각 부분들을 객체로 표현한 API (넓은 의미로는 웹 브라우저가 HTML 페이지를 인식하는 방식/ 좁은 의미로는 **문서객체** (html문서의 태그들을 JS가 이용할 수 있는 객체로 만드는 것  관련된 객체의 집합 
     >
     > : 노드구조로 트리형태로 표현된다.

     

  3. **CSS결정**

     :  CSS 스타일을 분석해 태그에 스타일 규칙을 적용한다.

  4. **레이아웃**

     : 렌더링 트리에서 위치나 크기를 가지고 있지 않기 때문에 객체들에게 위치와 크기를 정해주는 과정을 레이아웃이라고 한다.

  5. **그리기**

     : 렌더링 트리를 탐색하면서 그리기 (렌더링 엔진은 가능하면 HTML 문서가 파싱될 때까지 기다리지 않고, 배치와 그리기 과정을 시작한다.)

  

  ![브라우저의동작과정](https://d2.naver.com/content/images/2015/06/helloworld-59361-3.png)

  https://d2.naver.com/helloworld/59361

  추가로 공부하자...









 